\begin{lstlisting}
std::priority_queue<celda> mceldas2;
    for (int i = 0; i < nCellsWidth; ++i)
    {
    	for (int j = 0; j < nCellsHeight; ++j)
    	{
    		mceldas2.push(celda(i,j,cellValue2(i,j,freeCells,nCellsWidth,nCellsHeight,mapWidth,mapHeight,obstacles,defenses)));
    	}
    }
    

    while(currentDefense != defenses.end()) {
    	colocado=false;
    	while(!mceldas2.empty() && !colocado){
    		cactual=mceldas2.top();
            mceldas2.pop();
    		if(factible(cactual.row,cactual.col,nCellsWidth,nCellsHeight,mapWidth,mapHeight,obstacles,defenses,currentDefense)){
    			(*currentDefense)->position.x = (cactual.row * cellWidth) + cellWidth * 0.5f;
        		(*currentDefense)->position.y = (cactual.col * cellHeight) + cellHeight * 0.5f;
        		(*currentDefense)->position.z = 0; 
                colocado=true;
    		}
    	}
        ++currentDefense;
    	
    }

#ifdef PRINT_DEFENSE_STRATEGY

    float** cellValues = new float* [nCellsHeight]; 
    for(int i = 0; i < nCellsHeight; ++i) {
       cellValues[i] = new float[nCellsWidth];
       for(int j = 0; j < nCellsWidth; ++j) {
           cellValues[i][j] = ((int)(cellValue(i, j))) % 256;
       }
    }
    dPrintMap("strategy.ppm", nCellsHeight, nCellsWidth, cellHeight, cellWidth, freeCells
                         , cellValues, std::list<Defense*>(), true);

    for(int i = 0; i < nCellsHeight ; ++i)
        delete [] cellValues[i];
	delete [] cellValues;
	cellValues = NULL;

\end{lstlisting}
